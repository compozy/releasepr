# git-cliff ~ configuration file
# https://git-cliff.org/docs/configuration
#
# Research Summary (2024-2025):
# - git-cliff best practices include conventional commits parsing with semantic versioning
# - Use `--unreleased` flag for Release PR, `--bump` for version calculation
# - Configure custom major/minor increment regex for flexibility
# - Support for BREAKING CHANGE detection and proper grouping
# - Integration with GoReleaser via CHANGELOG.md for release notes

[changelog]
# Template for the changelog header
header = """
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
"""

# Template for the changelog body
# https://tera.netlify.app/docs
body = """
{% if version %}\
    ## {{ version | trim_start_matches(pat="v") }} - {{ timestamp | date(format="%Y-%m-%d") }}
{% else %}\
    ## Unreleased
{% endif %}\
{% for group, commits in commits | group_by(attribute="group") %}
    ### {{ group | upper_first }}
    {% for commit in commits
    | filter(attribute="scope")
    | sort(attribute="scope") %}
        - *({{commit.scope}})* {{ commit.message | upper_first }}\
            {%- if commit.breaking %}
        {% raw %}  {% endraw %}- **BREAKING:** {{commit.breaking_description}}
        {%- endif -%}
    {%- endfor -%}
    {% raw %}\n{% endraw %}\
    {%- for commit in commits %}
        {%- if commit.scope -%}
        {% else -%}
            - {{ commit.message | upper_first }}\
            {% if commit.breaking -%}
            {% raw %}  {% endraw %}- **BREAKING:** {{commit.breaking_description}}
            {% endif -%}
        {% endif -%}
    {% endfor -%}
{% endfor %}\n
"""

# Template for the changelog footer
footer = """
{% if remote.github -%}
    {% for release in releases -%}
        {% if release.version and release.previous and release.previous.version -%}
            [{{ release.version | trim_start_matches(pat="v") }}]: https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}/compare/{{ release.previous.version }}...{{ release.version }}
        {% elif release.version -%}
            [{{ release.version | trim_start_matches(pat="v") }}]: https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}/releases/tag/{{ release.version }}
        {% elif release.previous and release.previous.version -%}
            [unreleased]: https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}/compare/{{ release.previous.version }}...HEAD
        {% endif -%}
    {% endfor -%}
{% endif -%}

---
*Generated by [git-cliff](https://git-cliff.org)*
"""

# Remove leading and trailing whitespace
trim = true

[git]
# Parse commits according to the Conventional Commits specification
conventional_commits = true

# Filter out non-conventional commits (can be disabled to include all commits)
filter_unconventional = true

# Process each line of a commit as an individual commit
split_commits = false

# Regex for preprocessing the commit messages
commit_preprocessors = [
  # Fix common typos/formatting issues
  { pattern = '  +', replace = " "},
]

# Commit parsers for grouping commits
commit_parsers = [
  # Features
  { message = "^feat", group = "🎉 Features" },
  { message = "^feature", group = "🎉 Features" },

  # Bug Fixes
  { message = "^fix", group = "🐛 Bug Fixes" },
  { message = "^bugfix", group = "🐛 Bug Fixes" },

  # Performance
  { message = "^perf", group = "⚡ Performance Improvements" },

  # Security
  { message = "^security", group = "🔒 Security" },

  # Documentation
  { message = "^docs", group = "📚 Documentation" },

  # Build & CI
  { message = "^build", group = "📦 Build System" },
  { message = "^ci", group = "🔧 CI/CD" },

  # Refactoring
  { message = "^refactor", group = "♻️  Refactoring" },

  # Testing
  { message = "^test", group = "🧪 Testing" },

  # Dependencies
  { message = "^deps", group = "📦 Dependencies" },
  { message = "^chore\\(deps\\)", group = "📦 Dependencies" },

  # Style
  { message = "^style", group = "💅 Style" },

  # Chore - skip most of them
  { message = "^chore\\(release\\):", skip = true },
  { message = "^chore", group = "🔧 Miscellaneous Tasks" },

  # Revert commits
  { message = "^revert", group = "⏪ Reverts" },

  # Skip certain patterns
  { message = "^Merge branch", skip = true },
  { message = "^Merge pull request", skip = true },
  { message = "^Merge remote-tracking branch", skip = true },
  { message = "^wip", skip = true },
  { message = "^WIP", skip = true },

  # Catch-all for other conventional commits
  { message = ".*", group = "Other Changes" },
]

# Protect breaking changes from being skipped by other parsers
protect_breaking_commits = true

# Filter out commits that don't match any parser
filter_commits = false

# Tag pattern to match for releases (semver)
tag_pattern = "v[0-9].*"

# Sort commits inside groups
sort_commits = "oldest"

# Limit the number of commits included (optional)
# limit_commits = 1000

[bump]
# Bump configuration for semantic versioning

# When true, features always trigger a minor version bump
# When false with major version 0, features trigger patch bump
features_always_bump_minor = false  # Alpha: features bump patch on 0.x.x

# When true, breaking changes always trigger a major version bump
# When false with major version 0, breaking changes trigger minor bump
breaking_always_bump_major = false  # Alpha: breaking changes bump minor on 0.x.x

# Initial tag to use when no tags exist
initial_tag = "v0.0.10"

# Custom regex patterns to trigger specific version bumps
# These override the conventional commit analysis
custom_major_increment_regex = "MAJOR|BREAKING[- ]CHANGE"
custom_minor_increment_regex = "feat|feature|MINOR"

# Bump type can be manually specified (major, minor, patch)
# Useful for release workflows where you want explicit control
# bump_type = "minor"
